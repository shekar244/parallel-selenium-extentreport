package com.p13nservice.e2e.utils;

import org.testng.annotations.Test;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;

/**
 * Utility class to find all TestNG test methods in src/test folder with their fully qualified package names.
 * 
 * Usage:
 *   java com.p13nservice.e2e.utils.TestMethodFinder [testsFolderPath]
 * 
 * If no path is provided, it defaults to scanning src/test
 * The program will recursively scan all folders under the given path to find TestNG test methods.
 */
public class TestMethodFinder {
    
    private static final String DEFAULT_TESTS_PATH = "src/test";
    private static final String CLASS_FILE_EXTENSION = ".class";
    private static final String JAVA_FILE_EXTENSION = ".java";
    
    public static void main(String[] args) {
        String testsPath = args.length > 0 ? args[0] : DEFAULT_TESTS_PATH;
        String outputFile = "test-methods.csv";
        
        // Check if output file is specified as second argument
        if (args.length > 1) {
            outputFile = args[1];
        }
        
        System.out.println("Scanning for test methods in: " + testsPath);
        System.out.println("=" .repeat(80));
        
        try {
            List<TestMethodInfo> testMethods = findTestMethods(testsPath);
            
            if (testMethods.isEmpty()) {
                System.out.println("No test methods found.");
            } else {
                System.out.println("\nFound " + testMethods.size() + " test method(s):\n");
                
                // Sort methods for consistent output
                testMethods.sort(Comparator.comparing(TestMethodInfo::getPackageName)
                    .thenComparing(TestMethodInfo::getClassName)
                    .thenComparing(TestMethodInfo::getMethodName));
                
                // Write to CSV file
                writeToCSV(testMethods, outputFile);
                System.out.println("Results written to: " + outputFile);
                
                // Also print to console
                printToConsole(testMethods);
            }
            
        } catch (Exception e) {
            System.err.println("Error scanning for test methods: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Writes test methods to a CSV file.
     */
    private static void writeToCSV(List<TestMethodInfo> testMethods, String outputFile) throws IOException {
        try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(Paths.get(outputFile)))) {
            // Write header
            writer.println("packageName,ClassName,MethodName");
            
            // Write data rows
            for (TestMethodInfo method : testMethods) {
                writer.println(escapeCSV(method.getPackageName()) + "," +
                             escapeCSV(method.getClassName()) + "," +
                             escapeCSV(method.getMethodName()));
            }
        }
    }
    
    /**
     * Escapes CSV values (handles commas and quotes in values).
     */
    private static String escapeCSV(String value) {
        if (value == null) {
            return "";
        }
        // If value contains comma, quote, or newline, wrap in quotes and escape quotes
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
    
    /**
     * Prints test methods to console in formatted columns.
     */
    private static void printToConsole(List<TestMethodInfo> testMethods) {
        // Calculate column widths
        int packageWidth = Math.max("packageName".length(), 
            testMethods.stream().mapToInt(m -> m.getPackageName().length()).max().orElse(20));
        int classWidth = Math.max("ClassName".length(), 
            testMethods.stream().mapToInt(m -> m.getClassName().length()).max().orElse(20));
        int methodWidth = Math.max("MethodName".length(), 
            testMethods.stream().mapToInt(m -> m.getMethodName().length()).max().orElse(20));
        
        // Add padding
        packageWidth = Math.max(packageWidth + 2, 25);
        classWidth = Math.max(classWidth + 2, 30);
        methodWidth = Math.max(methodWidth + 2, 30);
        
        // Print header
        String headerFormat = "%-" + packageWidth + "s %-" + classWidth + "s %-" + methodWidth + "s";
        String separator = "-".repeat(packageWidth) + " " + "-".repeat(classWidth) + " " + "-".repeat(methodWidth);
        
        System.out.println(String.format(headerFormat, "packageName", "ClassName", "MethodName"));
        System.out.println(separator);
        
        // Print data rows
        String dataFormat = "%-" + packageWidth + "s %-" + classWidth + "s %-" + methodWidth + "s";
        for (TestMethodInfo method : testMethods) {
            System.out.println(String.format(dataFormat,
                method.getPackageName(),
                method.getClassName(),
                method.getMethodName()));
        }
    }
    
    /**
     * Finds all test methods in the specified directory.
     * Recursively scans all folders under the given path to find TestNG test methods.
     * 
     * @param testsPath Path to the tests directory (e.g., "src/test")
     * @return List of test method information
     */
    public static List<TestMethodInfo> findTestMethods(String testsPath) throws Exception {
        List<TestMethodInfo> testMethods = new ArrayList<>();
        Path testsDir = Paths.get(testsPath);
        
        if (!Files.exists(testsDir)) {
            System.err.println("Error: Directory does not exist: " + testsPath);
            return testMethods;
        }
        
        // First, try to find compiled classes from target/test-classes
        // Map src/test/java -> target/test-classes
        Path compiledTestsDir = getCompiledTestsPath(testsPath);
        if (Files.exists(compiledTestsDir)) {
            System.out.println("Scanning compiled classes from: " + compiledTestsDir);
            testMethods.addAll(findTestMethodsFromCompiledClasses(compiledTestsDir));
            if (!testMethods.isEmpty()) {
                return testMethods;
            }
        }
        
        // Fallback: scan source files and extract package/class info, then try to load
        System.out.println("Scanning source files from: " + testsPath);
        Files.walkFileTree(testsDir, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (file.toString().endsWith(JAVA_FILE_EXTENSION)) {
                    try {
                        // Extract package and class name from source file
                        TestClassInfo classInfo = extractClassInfoFromSource(file, testsDir);
                        if (classInfo != null && classInfo.isValid()) {
                            // First try to load the class and find test methods using reflection
                            List<TestMethodInfo> methods = findTestMethodsInClass(classInfo.getFullClassName());
                            
                            // If reflection didn't work (class not compiled), parse source file directly
                            if (methods.isEmpty()) {
                                methods = findTestMethodsFromSource(file, classInfo);
                            }
                            
                            testMethods.addAll(methods);
                        }
                    } catch (Exception e) {
                        // Silently skip files that can't be processed
                    }
                }
                return FileVisitResult.CONTINUE;
            }
        });
        
        return testMethods;
    }
    
    /**
     * Maps source test path to compiled test path.
     * e.g., src/test -> target/test-classes
     */
    private static Path getCompiledTestsPath(String sourcePath) {
        if (sourcePath.startsWith("src/test")) {
            String relativePath = sourcePath.substring("src/test".length());
            if (relativePath.startsWith("/") || relativePath.startsWith(File.separator)) {
                relativePath = relativePath.substring(1);
            }
            if (relativePath.isEmpty()) {
                return Paths.get("target/test-classes");
            }
            return Paths.get("target/test-classes", relativePath);
        }
        return Paths.get("target/test-classes");
    }
    
    /**
     * Finds test methods by scanning compiled .class files in target/test-classes.
     * Recursively scans all folders to find all test classes.
     */
    private static List<TestMethodInfo> findTestMethodsFromCompiledClasses(Path compiledTestsDir) throws Exception {
        List<TestMethodInfo> testMethods = new ArrayList<>();
        Set<String> processedClasses = new HashSet<>();
        
        Files.walkFileTree(compiledTestsDir, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                if (file.toString().endsWith(CLASS_FILE_EXTENSION)) {
                    try {
                        String className = getClassNameFromClassFile(file);
                        if (className != null && !processedClasses.contains(className)) {
                            processedClasses.add(className);
                            List<TestMethodInfo> methods = findTestMethodsInClass(className);
                            testMethods.addAll(methods);
                        }
                    } catch (Exception e) {
                        // Ignore classes that can't be loaded
                    }
                }
                return FileVisitResult.CONTINUE;
            }
        });
        
        return testMethods;
    }
    
    /**
     * Extracts package and class information from a Java source file.
     */
    private static TestClassInfo extractClassInfoFromSource(Path javaFile, Path baseDir) throws IOException {
        List<String> lines = Files.readAllLines(javaFile);
        String packageName = null;
        String className = null;
        
        // Extract package name
        for (String line : lines) {
            String trimmed = line.trim();
            if (trimmed.startsWith("package ")) {
                packageName = trimmed.substring(8, trimmed.indexOf(';')).trim();
                break;
            }
        }
        
        // Extract class name
        for (String line : lines) {
            String trimmed = line.trim();
            if (trimmed.contains("class ") && !trimmed.startsWith("//")) {
                // Find class declaration: public class ClassName or class ClassName
                int classIndex = trimmed.indexOf("class ");
                if (classIndex != -1) {
                    String afterClass = trimmed.substring(classIndex + 6).trim();
                    // Extract class name (before extends, implements, or {)
                    int spaceIndex = afterClass.indexOf(' ');
                    int extendsIndex = afterClass.indexOf(" extends ");
                    int implementsIndex = afterClass.indexOf(" implements ");
                    int braceIndex = afterClass.indexOf('{');
                    
                    int endIndex = afterClass.length();
                    if (spaceIndex != -1 && spaceIndex < endIndex) endIndex = spaceIndex;
                    if (extendsIndex != -1 && extendsIndex < endIndex) endIndex = extendsIndex;
                    if (implementsIndex != -1 && implementsIndex < endIndex) endIndex = implementsIndex;
                    if (braceIndex != -1 && braceIndex < endIndex) endIndex = braceIndex;
                    
                    className = afterClass.substring(0, endIndex).trim();
                    break;
                }
            }
        }
        
        if (packageName != null && className != null) {
            return new TestClassInfo(packageName, className);
        }
        
        return null;
    }
    
    /**
     * Gets the fully qualified class name from a compiled .class file path.
     * Extracts package structure from target/test-classes directory.
     */
    private static String getClassNameFromClassFile(Path classFile) {
        try {
            Path fullPath = classFile.toAbsolutePath();
            String fullPathStr = fullPath.toString();
            
            // Find the position after "test-classes/"
            int testClassesIndex = fullPathStr.indexOf("test-classes" + File.separator);
            if (testClassesIndex != -1) {
                String afterTestClasses = fullPathStr.substring(testClassesIndex + "test-classes".length() + 1);
                String className = afterTestClasses
                    .replace(File.separator, ".")
                    .replace(CLASS_FILE_EXTENSION, "");
                return className;
            }
            
            return null;
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Inner class to hold class information extracted from source files.
     */
    static class TestClassInfo {
        private final String packageName;
        private final String className;
        
        public TestClassInfo(String packageName, String className) {
            this.packageName = packageName;
            this.className = className;
        }
        
        public String getPackageName() {
            return packageName;
        }
        
        public String getClassName() {
            return className;
        }
        
        public String getFullClassName() {
            return packageName + "." + className;
        }
        
        public boolean isValid() {
            return packageName != null && !packageName.isEmpty() 
                && className != null && !className.isEmpty();
        }
    }
    
    /**
     * Finds all test methods in a given class using reflection.
     */
    private static List<TestMethodInfo> findTestMethodsInClass(String className) {
        List<TestMethodInfo> testMethods = new ArrayList<>();
        
        try {
            Class<?> clazz = Class.forName(className);
            
            // Get all methods from the class
            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();
            
            for (java.lang.reflect.Method method : methods) {
                // Check if method has @Test annotation
                if (method.isAnnotationPresent(Test.class)) {
                    String packageName = clazz.getPackage() != null ? clazz.getPackage().getName() : "";
                    String simpleClassName = clazz.getSimpleName();
                    String methodName = method.getName();
                    
                    testMethods.add(new TestMethodInfo(packageName, simpleClassName, methodName));
                }
            }
            
        } catch (ClassNotFoundException e) {
            // Class not found, might not be compiled yet - will fall back to source parsing
        } catch (Exception e) {
            // Ignore classes that can't be loaded or don't have test methods
        }
        
        return testMethods;
    }
    
    /**
     * Finds test methods by parsing Java source file directly.
     * This is used when classes are not compiled or not on classpath.
     */
    private static List<TestMethodInfo> findTestMethodsFromSource(Path javaFile, TestClassInfo classInfo) {
        List<TestMethodInfo> testMethods = new ArrayList<>();
        
        try {
            List<String> lines = Files.readAllLines(javaFile);
            
            // Find all @Test annotations and their associated methods
            for (int i = 0; i < lines.size(); i++) {
                String line = lines.get(i);
                String trimmed = line.trim();
                
                // Skip comments
                if (trimmed.startsWith("//") || trimmed.startsWith("/*") || trimmed.startsWith("*")) {
                    continue;
                }
                
                // Check if line contains @Test annotation (handle both @Test and @Test(...))
                if (trimmed.contains("@Test")) {
                    // Look ahead up to 10 lines for method declaration
                    for (int j = i + 1; j < Math.min(i + 11, lines.size()); j++) {
                        String methodLine = lines.get(j);
                        String methodTrimmed = methodLine.trim();
                        
                        // Skip empty lines and comments
                        if (methodTrimmed.isEmpty() || methodTrimmed.startsWith("//") || methodTrimmed.startsWith("/*")) {
                            continue;
                        }
                        
                        // Pattern to match method declarations: [modifiers] [return_type] methodName([parameters])
                        // Examples: "public void methodName(", "private static void methodName(", etc.
                        java.util.regex.Pattern methodPattern = java.util.regex.Pattern.compile(
                            ".*?(public|private|protected)?\\s*(static\\s+)?(final\\s+)?(synchronized\\s+)?(void|[\\w<>\\[\\]\\s,?]+)\\s+(\\w+)\\s*\\("
                        );
                        java.util.regex.Matcher matcher = methodPattern.matcher(methodTrimmed);
                        
                        if (matcher.find()) {
                            // Extract method name (group 6)
                            String methodName = matcher.group(6);
                            if (methodName != null && !methodName.isEmpty() && 
                                !methodName.equals("class") && !methodName.equals("interface") &&
                                !methodName.equals("enum") && !methodName.equals("if") &&
                                !methodName.equals("for") && !methodName.equals("while")) {
                                testMethods.add(new TestMethodInfo(
                                    classInfo.getPackageName(),
                                    classInfo.getClassName(),
                                    methodName
                                ));
                            }
                            break; // Found method, move to next @Test
                        }
                    }
                }
            }
        } catch (IOException e) {
            // Ignore files that can't be read
        }
        
        return testMethods;
    }
    
    /**
     * Inner class to hold test method information.
     */
    static class TestMethodInfo {
        private final String packageName;
        private final String className;
        private final String methodName;
        
        public TestMethodInfo(String packageName, String className, String methodName) {
            this.packageName = packageName;
            this.className = className;
            this.methodName = methodName;
        }
        
        public String getPackageName() {
            return packageName;
        }
        
        public String getClassName() {
            return className;
        }
        
        public String getMethodName() {
            return methodName;
        }
        
        public String getFullQualifiedName() {
            return packageName + "." + className + "." + methodName;
        }
        
        @Override
        public String toString() {
            return getFullQualifiedName();
        }
    }
}

